Character-Set library				-*- outline -*-
Olin Shivers
98/11/8
Last Update: 99/10/17

Emacs should display this document in outline mode. Say c-h m for
instructions on how to move through it by sections (e.g., c-c c-n, c-c c-p).

* Table of contents
-------------------
Abstract
Issues
Rationale
Specification
Implementation
Copyright


-------------------------------------------------------------------------------
* Abstract
----------

The ability to efficiently represent and manipulate sets of characters is an
unglamorous but very useful capability for text-processing code -- one that
tends to pop up in the definitions of other libraries.  Hence it is useful to
specify a general substrate for this functionality early.  This SRFI defines a
general library that provides this functionality. It is accompanied by a
reference implementation for the spec. The reference implementation is fairly
efficient, straightforwardly portable, and has a "free software" copyright.
The implementations are tuned for "small" 7 or 8 bit character types, such as
ASCII or Latin-1; the data structures and algorithms would have to be altered
for larger 16 or 32 bit character types such as Unicode -- however, the specs
have been designed with these larger character type in mind.

This library is being proposed as a SRFI now, as several forthcoming SRFIs
will be defined in terms of them:
    - string library
    - delimited input procedures (e.g., READ-LINE)
    - regular expressions

* Issues
--------
Latin-1 defs for primitive sets
  This spec should also provide the Latin-1 definitions for the primitive
  character sets. I'd appreciate it if some knowledgeable European could send 
  them to me.

Generalise ASCII-RANGE->CHAR-SET
  Generalise to LATIN-1? What's the right thing here?

-------------------------------------------------------------------------------
* Rationale
-----------

The ability to efficiently manipulate sets of characters is extremely
useful for text-processing code. Encapsulating this functionality in
a general, efficiently implemented library can assist all such code.
This library defines a new data structure to represent these sets, called
a "char-set." The char-set type is distinct from all other types.

-------------------------------------------------------------------------------
* Specification
---------------

** Procedure index
==================

Here is the complete set of bindings -- procedural and otherwise --
exported by this library. In a Scheme system that has a module or package 
system, these procedures should be contained in a module named "char-set-lib".

char-set? char-set= char-set<=

char-set-for-each char-set-fold 
char-set-unfold char-set-unfold!
char-set-map char-set-map!

char-set chars->char-set string->char-set 
ascii-range->char-set predicate->char-set ->char-set

char-set-size char-set-count char-set-members char-set-contains?

char-set-every char-set-any

char-set-adjoin  char-set-delete char-set-adjoin! char-set-delete!
char-set-invert  char-set-union  char-set-intersection  char-set-difference
char-set-invert! char-set-union! char-set-intersection! char-set-difference!
char-set-xor  char-set-diff+intersection
char-set-xor! char-set-diff+intersection!

char-set-copy

char-set:lower-case	char-set:upper-case	char-set:alphabetic
char-set:numeric	char-set:alphanumeric	char-set:graphic
char-set:printing	char-set:whitespace	char-set:blank
char-set:control	char-set:punctuation	char-set:hex-digit
char-set:ascii		char-set:empty		char-set:full

char-lower-case?	char-upper-case?	char-alphabetic?
char-numeric?		char-alphanumeric?	char-graphic?
char-printing?		char-whitespace?	char-blank?
char-control?		char-punctuation?	char-hex-digit?
char-ascii?

** General procedures
=====================
char-set? x -> boolean
    Is the object X a character set?

char-set= cs1 cs2 ... -> boolean
    Are the character sets equal?

char-set<= cs1 cs2 ... -> boolean
    Returns true if every character set CSi is 
    a subset of character set CSi+1.

char-set-fold kons knil cs -> object
    This is the fundamental iterator for character sets.  Applies the function
    KONS across the character set CS using initial state value KNIL.  That is,
    if CS is the empty set, the procedure returns KNIL.  Otherwise, some
    element c of CS is chosen; let cs' be the remaining, unchosen characters.
    The procedure returns
	(char-set-fold KONS (KONS c KNIL) cs')

    Examples:
        ;; CHAR-SET-MEMBERS
	(lambda (cs) (char-set-fold cons '() cs))

        ;; CHAR-SET-SIZE
        (lambda (cs) (char-set-fold (lambda (c i) (+ i 1)) 0 cs))

        ;; How many vowels in the char set?
        (lambda (cs) 
          (char-set-fold (lambda (c i) (if (vowel? c) (+ i 1) i))
                         0 cs))

char-set-for-each proc cs -> unspecific
    Apply procedure PROC to each character in the character set CS.
    Note that the order in which PROC is applied to the characters in the
    set is not specified, and may even change from application to application.

char-set-map proc char-set -> char-set
  PROC is a char->char procedure. Apply it to all the characters in
  the char-set argument, and collect the results into a new character set.

  Essentially lifts PROC from a char->char procedure to a char-set -> char-set
  procedure.

  Example:
    (char-set-map char-upcase cset)

char-set-unfold  f p g seed -> char-set
char-set-unfold! f p g cset0 seed -> char-set
    This is a fundamental constructor for char-sets. 
    - G is used to generate a series of "seed" values from the initial seed:
	SEED, (G SEED), (G^2 SEED), (G^3 SEED), ...
    - P tells us when to stop -- when it returns true when applied to one 
      of these seed values.
    - F maps each seed value to a character. These characters are collected
      together to form the character set (for CHAR-SET-UNFOLD), or
      added to CSET0 in a linear-update (for CHAR-SET-UNFOLD!).

    More precisely, the following definitions hold (although the actual
    implementation may be more efficient):

    (define (char-set-unfold p f g seed) 
      (char-set-unfold! p f g (char-set-copy char-set:empty) seed))

    (define (char-set-unfold! p f g cset0 seed)
      (let lp ((seed seed) (cset cset0))
	(if (p seed) cset				; P says we are done.
	    (lp (g seed)				; Loop on (G SEED).
		(char-set-adjoin! cset (f seed))))))	; Add (F SEED) to set.


    Examples:
                         
    (port->char-set p) = (char-set-unfold eof-object? values
                                          (lambda (x) (read-char p))
                                          (read-char p))

    (list->char-set lis) = (char-set-unfold null? car cdr lis)


** Creating character sets
==========================
char-set char1 ... -> char-set
    Return a character set containing the given characters.

chars->char-set chars -> char-set
    Return a character set containing the characters in the list CHARS.
    [LIST->CHAR-SET ?]

string->char-set s -> char-set
    Return a character set containing the characters in the string S.

predicate->char-set pred -> char-set
    Returns a character set containing every character c such that
    (PRED c) returns true.

ascii-range->char-set lower upper -> char-set
    Returns a character set containing every character whose ASCII
    code lies in the half-open range [LOWER,UPPER).

    What is the modern-day, Latin-1/Unicode equivalent to this procedure?

->char-set x -> char-set
    Coerces X into a char-set. X may be a string, character, char-set, or
    predicate. A string is converted to the set of its constituent characters;
    a character is converted to a singleton set; a char-set is returned
    as-is; a predicate is converted to a char-set using PREDICATE->CHAR-SET.
    This procedure is intended for use by other procedures that want to 
    provide "user-friendly," wide-spectrum interfaces to their clients.


** Querying character sets
==========================
char-set-members char-set -> character-list
    This procedure returns a list of the members of CHAR-SET.

char-set-contains? char-set char -> boolean
    This procedure tests CHAR for membership in set char-set.

    The MIT Scheme character set package called this procedure
    CHAR-SET-MEMBER?, but the argument order isn't consistent with the name.

char-set-size cs -> integer
    Returns the number of elements in character set CS.

char-set-count pred cs -> integer
    Apply PRED to the chars of character set CS, and return the number
    of chars that caused the predicate to return true.

char-set-every pred cs -> boolean
char-set-any pred cs -> object
    The CHAR-SET-EVERY procedure returns true if predicate PRED
    returns true of every character in the character set CS.

    Likewise, CHAR-SET-ANY applies PRED to every character in
    character set CS, and returns the first true value it finds.
    If no character produces a true value, it returns false.

    The order in which these procedures sequence through the elements of
    CS is not specified.


** Character-set algebra
========================
char-set-invert char-set                       -> char-set
char-set-union char-set1 ...                   -> char-set
char-set-intersection char-set1 char-set2 ...  -> char-set
char-set-difference char-set1 char-set2 ...    -> char-set
char-set-xor char-set1 char-set2 ...           -> char-set
char-set-diff+intersection char-set1 char-set2 -> [char-set char-set]
    These procedures implement set complement, union, intersection, 
    difference, and exclusive-or for character sets.  The union, intersection, and difference
    operations are n-ary, associating to the left; the difference function
    requires at least one argument, while union and intersection may be
    applied to zero arguments.

    CHAR-SET-DIFF+INTERSECTION returns both the difference and the
    intersection of the arguments.

char-set-adjoin cs char1 ... -> char-set
char-set-delete cs char1 ... -> char-set
    Add/delete the CHARi characters to/from character set CS.


** Standard character sets
==========================
Several character sets are predefined for convenience:
    char-set:lower-case		Lower-case alphabetic chars 
    char-set:upper-case		Upper-case alphabetic chars 
    char-set:alphabetic		Alphabetic chars 
    char-set:numeric		Decimal digits: 0-9 
    char-set:alphanumeric	Alphabetic or numeric 
    char-set:graphic		Printing characters except space 
    char-set:printing		Printing characters including space 
    char-set:whitespace		Whitespace characters 
    char-set:control		Control characters 
    char-set:punctuation	Punctuation characters 
    char-set:hex-digit		A hexadecimal digit: 0-9, A-F, a-f 
    char-set:blank		Blank characters 
    char-set:ascii		A character in the ASCII set. 
    char-set:empty		Empty set 
    char-set:full		All characters 

The first eleven of these correspond to the character classes defined in
Posix.  Note that there may be characters in CHAR-SET:ALPHABETIC that are
neither upper or lower case---this might occur in implementations that use a
character type richer than ASCII, such as Unicode.  A "graphic character" is
one that would put ink on your page.  While the exact composition of these
sets may vary depending upon the character type provided by the underlying
Scheme system, here are the definitions for some of the sets in an ASCII
character set:

    char-set:alphabetic		A-Z and a-z 
    char-set:lower-case		a-z 
    char-set:upper-case		A-Z 
    char-set:graphic		Alphanumeric + punctuation 
    char-set:whitespace		Space, newline, tab, page, 
				vertical tab, carriage return 
    char-set:blank		Space and tab 
    char-set:control		ASCII 0-31 and 127 
    char-set:punctuation	!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~

(This spec should also provide the Latin-1 definitions for these sets. I'd
appreciate it if some knowledgeable European could send them to me.)

char-alphabetic?   character -> boolean
char-lower-case?   character -> boolean
char-upper-case?   character -> boolean
char-numeric?	   character -> boolean
char-alphanumeric? character -> boolean
char-graphic?      character -> boolean
char-printing?     character -> boolean
char-whitespace?   character -> boolean
char-blank?        character -> boolean
char-control?      character -> boolean
char-punctuation?  character -> boolean
char-hex-digit?    character -> boolean
char-ascii?        character -> boolean
    These predicates are defined in terms of the above character sets.


** Linear-update character-set operations
=========================================
These procedures have a hybrid pure-functional/side-effecting semantics: they
are allowed, but not required, to side-effect one of their parameters in order
to construct their result.  An implementation may legally implement these
procedures as pure, side-effect-free functions, or it may implement them using
side effects, depending upon the details of what is the most efficient or
simple to implement in terms of the underlying representation.

What this means is that clients of these procedures *may not* rely upon these
procedures working by side effect.  For example, this is not guaranteed to
work:
    
    (let ((cs (char-set #\a #\b #\c)))
      (char-set-adjoin! cs #\d)
      cs) ; Could be either {a,b,c} or {a,b,c,d}.

However, this is well-defined:

    (let ((cs (char-set #\a #\b #\c)))
      (char-set-adjoin! cs #\d)) ; {a,b,c,d}

So clients of these procedures write in a functional style, but must
additionally be sure that, when the procedure is called, there are no
other live pointers to the potentially-modified character set (hence the term
"linear update").

There are two benefits to this convention:
  - Implementations are free to provide the most efficient possible
    implementation, either functional or side-effecting.
  - Programmers may nonetheless continue to assume that character sets
    are purely functional data structures: they may be reliably shared
    without needing to be copied, uniquified, and so forth.

Note that pure functional representations are the right thing for
ASCII- or Latin-1-based Scheme implementations, since a char-set can
be represented in an ASCII Scheme with 4 32-bit words. Pure set-algebra
operations on such a representation are very fast and efficient. Programmers
who code using linear-update operations are guaranteed the system will
provide the best implementation across multiple platforms.

In practice, these procedures are most useful for efficiently constructing
character sets in a side-effecting manner, in some limited local context, 
before passing the character set outside the local construction scope to be
used in a functional manner.

Scheme provides no assistance in checking the linearity of the potentially
side-effected parameters passed to these functions --- there's no linear
type checker or run-time mechanism for detecting violations. (But
sophisticated programming environments, such as DrScheme, might help.)

char-set-copy cs -> char-set
    Returns a copy of the character set CS.  "Copy" means that if either the
    input parameter or the result value of this procedure is passed to one of
    the linear-update procedures described below, the other character set is
    guaranteed not to be altered.  (A system that provides pure-functional
    implementations of the rest of the linear-operator suite could implement
    this procedure as the identity function.)

char-set-adjoin! cs char1 ... -> char-set
    Add the CHARi characters to character set CS, and return the result.  
    This procedure is allowed, but not required, to side-effect CS.

char-set-delete! cs char1 ... -> char-set
    Remove the CHARi characters to character set CS, and return the result. 
    This procedure is allowed, but not required, to side-effect CS.

char-set-map! proc char-set -> char-set
    Map char->char procedure PROC over the elements of the char-set argument, 
    collecting the results into the result char-set.
    This procedure is allowed, but not required, to side-effect CS.

char-set-invert! char-set                           -> char-set
char-set-union! char-set1 char-set2 ...             -> char-set
char-set-intersection! char-set1 char-set2 ...      -> char-set
char-set-difference! char-set1 char-set2 ...        -> char-set
char-set-xor! char-set1 char-set2 ...               -> char-set
char-set-diff+intersection! char-set1 char-set2 ... -> char-set
    These procedures implement set complement, union, intersection, difference
    and exclusive-or for character sets.  They are allowed, but not required,
    to side-effect their first parameter.  The union, intersection, and
    difference operations are n-ary, associating to the left.


-------------------------------------------------------------------------------
* Implementation
----------------

A reference implementation will be available soon.

-------------------------------------------------------------------------------
* Copyright
-----------

Certain portions of this document -- the specific, marked segments of text
describing the R5RS procedures -- were adapted with permission from the R5RS
report.
    
All other text is copyright (C) Olin Shivers (1998, 1999). 
All Rights Reserved. 

This document and translations of it may be copied and furnished to others,
and derivative works that comment on or otherwise explain it or assist in its
implementation may be prepared, copied, published and distributed, in whole or
in part, without restriction of any kind, provided that the above copyright
notice and this paragraph are included on all such copies and derivative
works. However, this document itself may not be modified in any way, such as
by removing the copyright notice or references to the Scheme Request For
Implementation process or editors, except as needed for the purpose of
developing SRFIs in which case the procedures for copyrights defined in the
SRFI process must be followed, or as required to translate it into languages
other than English.

The limited permissions granted above are perpetual and will not be revoked by
the authors or their successors or assigns.

This document and the information contained herein is provided on an "AS IS"
basis and THE AUTHORS AND THE SRFI EDITORS DISCLAIM ALL WARRANTIES, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
